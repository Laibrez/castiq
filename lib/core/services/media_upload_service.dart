import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:cloudinary_public/cloudinary_public.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:image_picker/image_picker.dart';

class MediaUploadService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final ImagePicker _picker = ImagePicker();
  final CloudinaryPublic _cloudinary = CloudinaryPublic('dhkugnymi', 'castiq', cache: false);

  // Pick a video from gallery or camera
  Future<XFile?> pickVideo({bool fromCamera = false}) async {
    return await _picker.pickVideo(
      source: fromCamera ? ImageSource.camera : ImageSource.gallery,
      maxDuration: const Duration(minutes: 2),
    );
  }

  // Pick multiple images from gallery
  Future<List<XFile>> pickMultipleImages() async {
    return await _picker.pickMultiImage(imageQuality: 85);
  }

  // Pick a single image
  Future<XFile?> pickImage({bool fromCamera = false}) async {
    return await _picker.pickImage(
      source: fromCamera ? ImageSource.camera : ImageSource.gallery,
      imageQuality: 85,
    );
  }

  // Upload video with progress callback
  Future<String?> uploadVideo({
    required String userId,
    required File videoFile,
    required Function(double) onProgress,
  }) async {
    try {
      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();
      
      // Note: pure cloudinary_public doesn't emit progress in the same granular way as Firebase
      // We will simulate completion for now or use the Future completion.
      // Since specific progress hooks might not be available in this package version without deeper config,
      // we'll just await the upload.
      
      onProgress(0.1); // Started
      
      CloudinaryResponse response = await _cloudinary.uploadFile(
        CloudinaryFile.fromFile(
          videoFile.path,
          identifier: 'video_$timestamp',
          folder: 'portfolios/$userId',
          resourceType: CloudinaryResourceType.Video,
        ),
      );
      
      onProgress(1.0); // Completed

      final downloadUrl = response.secureUrl;

      // Update Firestore
      await _firestore.collection('users').doc(userId).update({
        'portfolioVideo': downloadUrl,
      });

      return downloadUrl;
    } catch (e) {
      print('Error uploading video: $e');
      return null;
    }
  }

  // Upload multiple images with progress callback
  Future<List<String>> uploadMultipleImages({
    required String userId,
    required List<File> imageFiles,
    required Function(int completed, int total) onProgress,
  }) async {
    List<String> downloadUrls = [];

    for (int i = 0; i < imageFiles.length; i++) {
      try {
        final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();
        
        CloudinaryResponse response = await _cloudinary.uploadFile(
          CloudinaryFile.fromFile(
            imageFiles[i].path,
            identifier: 'image_${timestamp}_$i',
            folder: 'portfolios/$userId',
          ),
        );
        
        downloadUrls.add(response.secureUrl);
        onProgress(i + 1, imageFiles.length);
      } catch (e) {
        print('Error uploading image $i: $e');
        // Continue with other images
      }
    }

    // Update Firestore with all image URLs
    // Note: This appends to the array. If the user wants to replace, logic might need adjustment elsewhere.
    // The previous implementation used arrayUnion, which appends.
    if (downloadUrls.isNotEmpty) {
      await _firestore.collection('users').doc(userId).update({
        'portfolioImages': FieldValue.arrayUnion(downloadUrls),
      });
    }

    return downloadUrls;
  }

  // Upload a single image (for profile photo, etc.)
  Future<String?> uploadSingleImage({
    required String userId,
    required File imageFile,
    required String folder,
    required Function(double) onProgress,
  }) async {
    try {
      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();
      
      onProgress(0.1); 

      CloudinaryResponse response = await _cloudinary.uploadFile(
        CloudinaryFile.fromFile(
          imageFile.path,
          identifier: 'image_$timestamp',
          folder: '$folder/$userId',
        ),
      );

      onProgress(1.0);
      
      return response.secureUrl;
    } catch (e) {
      print('Error uploading single image: $e');
      return null;
    }
  }

  // Delete a media file from storage
  Future<bool> deleteMedia(String url) async {
    // Cloudinary unsigned deletion from client side safely is not typically supported 
    // without using a signature generated by a backend or using the Admin API (bad practice on client).
    // For now, we will return false or just silently fail as "not supported yet".
    // To properly support this, we would need a Cloud Function or backend endpoint.
    print('Deleting Cloudinary media from client is not securely supported without backend signature.');
    return false; 
  }
}
